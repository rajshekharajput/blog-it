import { Command, LineChange, OutputChannel, SourceControlResourceState, TextDocumentShowOptions, Uri, TimelineItem } from 'vscode';
import TelemetryReporter from 'vscode-extension-telemetry';
import { Git } from './git';
import { Model } from './model';
import { Repository, Resource } from './repository';
export declare class CommandCenter {
    private git;
    private model;
    private outputChannel;
    private telemetryReporter;
    private disposables;
    private commandErrors;
    constructor(git: Git, model: Model, outputChannel: OutputChannel, telemetryReporter: TelemetryReporter);
    setLogLevel(): Promise<void>;
    refresh(repository: Repository): Promise<void>;
    openResource(resource: Resource): Promise<void>;
    openChanges(repository: Repository): Promise<void>;
    cloneRepository(url?: string, parentPath?: string, options?: {
        recursive?: boolean;
    }): Promise<void>;
    clone(url?: string, parentPath?: string): Promise<void>;
    cloneRecursive(url?: string, parentPath?: string): Promise<void>;
    init(skipFolderPrompt?: boolean): Promise<void>;
    openRepository(path?: string): Promise<void>;
    close(repository: Repository): Promise<void>;
    openFile(arg?: Resource | Uri, ...resourceStates: SourceControlResourceState[]): Promise<void>;
    openFile2(arg?: Resource | Uri, ...resourceStates: SourceControlResourceState[]): Promise<void>;
    openHEADFile(arg?: Resource | Uri): Promise<void>;
    openChange(arg?: Resource | Uri, ...resourceStates: SourceControlResourceState[]): Promise<void>;
    rename(repository: Repository, fromUri: Uri | undefined): Promise<void>;
    stage(...resourceStates: SourceControlResourceState[]): Promise<void>;
    stageAll(repository: Repository): Promise<void>;
    private _stageDeletionConflict;
    stageAllTracked(repository: Repository): Promise<void>;
    stageAllUntracked(repository: Repository): Promise<void>;
    stageAllMerge(repository: Repository): Promise<void>;
    stageChange(uri: Uri, changes: LineChange[], index: number): Promise<void>;
    stageSelectedChanges(changes: LineChange[]): Promise<void>;
    private _stageChanges;
    revertChange(uri: Uri, changes: LineChange[], index: number): Promise<void>;
    revertSelectedRanges(changes: LineChange[]): Promise<void>;
    private _revertChanges;
    unstage(...resourceStates: SourceControlResourceState[]): Promise<void>;
    unstageAll(repository: Repository): Promise<void>;
    unstageSelectedRanges(diffs: LineChange[]): Promise<void>;
    clean(...resourceStates: SourceControlResourceState[]): Promise<void>;
    cleanAll(repository: Repository): Promise<void>;
    cleanAllTracked(repository: Repository): Promise<void>;
    cleanAllUntracked(repository: Repository): Promise<void>;
    private _cleanTrackedChanges;
    private _cleanUntrackedChange;
    private _cleanUntrackedChanges;
    private smartCommit;
    private commitWithAnyInput;
    commit(repository: Repository): Promise<void>;
    commitStaged(repository: Repository): Promise<void>;
    commitStagedSigned(repository: Repository): Promise<void>;
    commitStagedAmend(repository: Repository): Promise<void>;
    commitAll(repository: Repository): Promise<void>;
    commitAllSigned(repository: Repository): Promise<void>;
    commitAllAmend(repository: Repository): Promise<void>;
    private _commitEmpty;
    commitEmpty(repository: Repository): Promise<void>;
    commitNoVerify(repository: Repository): Promise<void>;
    commitStagedNoVerify(repository: Repository): Promise<void>;
    commitStagedSignedNoVerify(repository: Repository): Promise<void>;
    commitStagedAmendNoVerify(repository: Repository): Promise<void>;
    commitAllNoVerify(repository: Repository): Promise<void>;
    commitAllSignedNoVerify(repository: Repository): Promise<void>;
    commitAllAmendNoVerify(repository: Repository): Promise<void>;
    commitEmptyNoVerify(repository: Repository): Promise<void>;
    restoreCommitTemplate(repository: Repository): Promise<void>;
    undoCommit(repository: Repository): Promise<void>;
    checkout(repository: Repository, treeish?: string): Promise<boolean>;
    checkoutDetached(repository: Repository, treeish?: string): Promise<boolean>;
    private _checkout;
    branch(repository: Repository): Promise<void>;
    branchFrom(repository: Repository): Promise<void>;
    private promptForBranchName;
    private _branch;
    deleteBranch(repository: Repository, name: string, force?: boolean): Promise<void>;
    renameBranch(repository: Repository): Promise<void>;
    merge(repository: Repository): Promise<void>;
    rebase(repository: Repository): Promise<void>;
    createTag(repository: Repository): Promise<void>;
    deleteTag(repository: Repository): Promise<void>;
    fetch(repository: Repository): Promise<void>;
    fetchPrune(repository: Repository): Promise<void>;
    fetchAll(repository: Repository): Promise<void>;
    pullFrom(repository: Repository): Promise<void>;
    pull(repository: Repository): Promise<void>;
    pullRebase(repository: Repository): Promise<void>;
    private _push;
    push(repository: Repository): Promise<void>;
    pushForce(repository: Repository): Promise<void>;
    pushFollowTags(repository: Repository): Promise<void>;
    pushFollowTagsForce(repository: Repository): Promise<void>;
    cherryPick(repository: Repository): Promise<void>;
    pushTo(repository: Repository, remote?: string, refspec?: string, setUpstream?: boolean): Promise<void>;
    pushToForce(repository: Repository, remote?: string, refspec?: string, setUpstream?: boolean): Promise<void>;
    pushTags(repository: Repository): Promise<void>;
    addRemote(repository: Repository): Promise<string | undefined>;
    removeRemote(repository: Repository): Promise<void>;
    private _sync;
    sync(repository: Repository): Promise<void>;
    syncAll(): Promise<void>;
    syncRebase(repository: Repository): Promise<void>;
    publish(repository: Repository): Promise<void>;
    ignore(...resourceStates: SourceControlResourceState[]): Promise<void>;
    revealInExplorer(resourceState: SourceControlResourceState): Promise<void>;
    private _stash;
    stash(repository: Repository): Promise<void>;
    stashIncludeUntracked(repository: Repository): Promise<void>;
    stashPop(repository: Repository): Promise<void>;
    stashPopLatest(repository: Repository): Promise<void>;
    stashApply(repository: Repository): Promise<void>;
    stashApplyLatest(repository: Repository): Promise<void>;
    stashDrop(repository: Repository): Promise<void>;
    private pickStash;
    timelineOpenDiff(item: TimelineItem, uri: Uri | undefined, _source: string): Promise<unknown>;
    resolveTimelineOpenDiffCommand(item: TimelineItem, uri: Uri | undefined, options?: TextDocumentShowOptions): Command | undefined;
    timelineCopyCommitId(item: TimelineItem, _uri: Uri | undefined, _source: string): Promise<void>;
    timelineCopyCommitMessage(item: TimelineItem, _uri: Uri | undefined, _source: string): Promise<void>;
    private _selectedForCompare;
    timelineSelectForCompare(item: TimelineItem, uri: Uri | undefined, _source: string): Promise<void>;
    timelineCompareWithSelected(item: TimelineItem, uri: Uri | undefined, _source: string): Promise<void>;
    rebaseAbort(repository: Repository): Promise<void>;
    private createCommand;
    private getSCMResource;
    private runByRepository;
    dispose(): void;
}
